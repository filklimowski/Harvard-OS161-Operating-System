Synchronization Problem 1: Of Mice and Cats

Our group implemented this solutions using locks instead of semaphores. Our team was more familiar with locks and condition variables having just finished coding them for Assignment 1. 

In our solution the program created two bowl structs (bowl1 and bowl2), three locks (Bowl_1, Bowl_2, and Openbowl_lock) and one condition variable (cv_openbowl). The bowl structs would contain two different states either FREE or LOCKED. Bowl_1 and Bowl_2 are strictly placed around the lock_eat statement to ensure that no two animals can eat from the same bowl at once. The bowl structs would be set to LOCKED only when that bowl's lock was acquired. Likewise, the bowl struct would be set to FREE when the bowl's lock had been released. The Openbowl_lock is a lock to control the amount of animals that are allowed to check if the animal is allowed to eat. The cv_openbowl condition variable worked alongside the Openbowl_lock to contain the animals in a list and prevent them from racing for locks.

The solution used for Catlock used a similar algorithm for both cats and mice where the program would constantly perform checks before allowing an animal to obtain bowls of food. Our team created conditions for each animal and only upon success would the animal be granted permission to obtain the bowl. The first condition created was to ensure that both bowls were not locked. If both bowls were locked then the thread would put itself to sleep and into a waiting queue. Then when a signal came for an open bowl, a single thread would wake up, remove itself from the queue and perform another check to see if a different species of animal had occupied the other bowl. If there was a different species then the thread would put itself back to sleep and rejoin the queue. Then another thread would wake up and perform the same checks. If this thread succeeded in its checks then it would obtain the empty bowl, signal the queue and release the Openbowl_lock. This loop would occur constantly until all the animals had eaten their respected number of meals.

The use of these conditions allowed us to avoid errors. By constantly checking the requirements of these conditions our team would ensure that both animals would eat separate from one another. Our team discovered that this flaw occur if the conditions to acquire the bowls were not checked constantly. Our team first tried using if loops instead of while loops to perform the check and our team discovered that this was flawed. Our team discovered an ordered number of steps that would break this algorithm: if two cats had obtained the bowl and one cat had finished eating it would release the openbowl lock. Then if the mouse was the next in the queue, an if statement was not sufficient enough for it to check both bowls for cats. Also the precise timing of the commands bowl unlock, cv_signal(), and lock_release() would ensure that a constant standby program would not occur. Our team had sleeping threads occurring frequently before discovering this timing. For example, if an animal failed its conditions to obtain a bowl it would put itself to sleep. Our group had not signaled the waking up of a thread and would cause the program to go into sleeping phase waiting for a thread_wakeup() that would never occur. Our group also prevented deadlocks from occurring by releasing the openbowl lock after the bowl lock was obtained. Our group ensured that once a thread had obtained its second lock that thread would signal and release the first one it had obtained ensuring that some animal would grab the lock. Our specific order of lock_acquire(bowl1), bowl1 = lock, lock_release(openbowl_lock) prevented two animals from obtaining a single bowl lock and deadlocks for a single lock.

Our group feels that this algorithm was a very effective solution. Using our synchronization primitives our team was able to devise a solution that was free from error. 


Synchronization Problem 2: Podunk Traffic Problem

	The traffic problem offered several synchronization problems that we were able to solve. One of the things our team wanted out of our implementation was to ensure that multiple cars could enter the intersection at the same time, as long as they didn't crash into other cars. With the current system in Podunk, the cars were going through the intersection one at a time, and had to wait until another car exited before going in. The challenges our team faced included getting multiple cars into the intersection at once, how to make sure no cars overtook the others as they approached the intersection(passing), how to avoid cars crashing, how to avoid starvation where a car approached the intersection but never got in, and how to avoid a deadlock where no cars could move out of a region or exit the intersection. The following overviews our team's implementation of a traffic system in Podunk, and why we did things the way we did to solve the challenges and problems we faced.

	To improve upon the current system, we wanted to have up to four cars in the intersection at once, as opposed to having just one. This way, as long as the cars weren't going into the same region at the same time (the north-west region, north-east region, south-west region, and south-east region), they could go ahead and enter the intersection. We implemented a system using condition variables and locks so that a car could enter the intersection from any side as long as it was able to acquire its first region  (eg. car coming from the north would try to acquire the north-west region). Having cars acquire one reagion at a time allowed us to implement our system the way we wanted with more than one car in the intersection at once (eg. if cars were turning right, they could all acquire their first region and exit successfully). 

	Each region had a lock associated with it, and for a car to acquire a region, it had to acquire the lock on that region. We created variables for each square that set them to 'LOCKED' and 'UNLOCKED', and if a region was 'LOCKED', the car trying to acquire that region would have to wait on the condition variable created for that region (eg. cv_regionNW). Once it was signalled by some car leaving that region, it could then acquire the lock and have exclusive access to that region. It could then set the region's variable to 'LOCKED', output the message saying it is in its desired region, and then go on to either the next region or leave. Once a car left a region, it would change the region's variable to 'UNLOCKED', and signal any car waiting on that region. Giving a car exclusive access to a region ensured that another major problem, which was having cars carsh into one another, never occured.

	Another problem that quickly arose at the intersection was that many cars would approach from one or many directions, and our team had to figure out how to avoid cars 'overlapping' or 'jumping' one another. This problem was solved by creating a wait queue before entering the intersection. That is, a condition variable was created for each direction, and a car would wait on a condition such as 'approaching_NORTH' to keep the correct order of cars coming in. A car would signal this condition only when it had already entered the intersection and left the first region. Then the next car in line (the first member of the wait queue) would be able to try to enter as well (which it only does by checking if its first region is locked - if so it still must wait until that region is available). Our team was able to utilize the wait queue in a condition variable wait to maintain order for all cars coming towards the intersection from any direction.

	Another significant problem the team faced in our implementation was avoiding deadlocks when multiple cars were in the intersection all trying to complete their respective turns. This could occur in the example that every car tried to go straight - each car would be able to acquire its first region, however would never be able to acquire the next region. This problem was solved by first determining how many squares the car had to go before actually going into the intersection. If it was trying to go straight, it would try to acquire both locks on its first two regions, and only if it succesfully got both would it go forward. If it could only lock one, it would not go forward, but instead wait on the second region until it could get both. This ensured that if there was already a car in one of the regions that a car was trying to go through, it would let that other car finish first. This added a slight delay for some cars when trying to go through the intersection but they were immediately woken up with a condition variable signal on the region they were waiting for. Making cars that go straight require both locks before they went forward ensured that they would be able to exit succesfully, and not have the case where they entered the intersection and couldn't get out.

	The problem with deadlocks extended to left turns as well, as our team needed to ensure that once a car enters the intersection, if it is going left, that it succesfully exits. A possible solution we considered was to follow upon the implementation of the straight turn, where instead of locking two regions before entering the intersection, the car would try and lock all three regions. However, this would slow down the efficiency of our solution significantly, since a car might have to wait a while before it can lock down three regions, and if other cars continue going into the intersection and continuously using the region locks that the car turning left is waiting on, it could wait much longer than what would be deemed fair. This could result in starvation and the car would potentially never get to go through.

	To make our solution more efficient than this, our left turn algorithm models on the straight through in the sense that it locks up its first two regions before entering the intersection. It then goes into the intersection, and waits in its second region until it is signalled that the third region it needs is availabe. It then gets this third region, and can succesfully leave. This implementation works because even if the car is waiting in its second region for a while, it will not deadlock since any car trying to access that region will see that it is locked, and will not be able to enter the intersection before that car has moved. Thus, if a car has gone into the intersection going straight or left, it will guarentee there are at most 3 cars in the intersection, always with one region available for a car to move to, preventing any deadlocks from ever happening.

	After implementing a seemingly correct solution, one last problem our team faced was that the scheduler would continue running threads while a printout ouf a message was occuring. Even though cars were getting into regions and leaving properly, messages would output out of order and thus show that there was a crash or a car had been overtaken, even if this was not the case. Our team solved this problem by putting a lock on the print out from the 'message' function call, ensuring no other threads tried to print messages at the same time. This lock on the print out fixed the errors we were having and all the cars succesfully enter and leave the intersection quickly and in order.

	As a whole our solution consists of acquiring multiple locks on regions inside the intersection to avoid deadlocks, waiting on regions that are currently occupied, signalling these regions when they are free to prevent crashes, and a wait queue of cars approaching to avoid cars overtaking one another. This solution works better than a traditional four way stop sign because it usually has two or three cars in the intersection at once, and up to four if all four cars are simultaneously turning right. Using our synchronization primitives extensively we were able to implement what we believe is a very elegant solution to the problem.
