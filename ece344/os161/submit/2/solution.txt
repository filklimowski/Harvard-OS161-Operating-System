Readchar System Call

	Readchar reads in a single input from the user using getch() and returns that character. If the character entered is end of file (ASCII value of 4) we made our implementation return 0. The calling program will handle what to do with the character that is read in; our implementation simply returns that character or 0 if it is a special character like the EOF character.


Waitpid System Call

	The bulk of the work for the system call sys_exit is done here. Waitpid handles all cases regarding parent to child exiting issues. I will first explain our team's pid structure. We created a list of pids that contain the pid's number and whether or not it has exited. This list grows whenever fork is called and increments a global pid counter which keeps tally on how many pids have been created. Fork then ensures that each process has its own unique pid. If ever a process were to call thread_fork each thread within that process will have a shared pid (this assignment only supports one thread per process). Another implementation we considered was to have a pidlist array but at the beginning of our implementation we weren't sure if we wanted a max number of processes, or what that number would be.

	We broke waitpid up into 2 cases and 2 subcases. The first case was to see if waitpid was allowed to wait on the child's pid. These cases included error checking to see if the pid was valid, if status was valid, if the pid exists, and to see if the pid was in fact waiting on a child and not a parent process. The second case was broken down to whether the child process was running or has exited. Wait called a function pidlist_search which searches for the pid in the list and returns whether or not the process has exited, along with its exitcode. If the process has not exited then the current thread will sleep on the child's pid. Once awoken it will search again, just as precaution, and call pidlist_search again. If this time the child thread has exited then the value of exitcode has already been copied over and wait will return its pid.

	By implementing waitpid this way we have handled all errors, deadlocks, and indefinite thread sleeping. By handling all errors at the beginning of waitpid our team ensured that no problems could arise on sleeping on a non-existent pid or a possible TLB miss. Once we knew that we had valid input it was just a matter of whether the child had exited before or after the waitpid call was entered. By using a list of current processes and their executing status we simplified the execution of waitpid. It also helped us easily retreive the exitcode.


Thread_join

	Thread_join works very similar to waitpid. The only difference is that we included exorcising the zombie threads at the bottom. Thread_join was created for the kernel to execute programs within a thread instead of creating a seperate process. The parent thread in common_prog in menu.c creates a pidlist entry for the child thread. It also assigns the child thread a unique pid. We did it this way because we knew that exit was going to be called on the child thread's newly created process. Exit would cause our parent's entry in pidlist to be classified as having exited already when in reality it would still be running. We could have handled this case specifically but our team decided to not change any of the implemenations of the system calls and instead make it work according to the system we had. Once the child thread's new position has been created the parent thread handles the cases that had been created by the wait system call. Once the program calls exit, the kernel will wake up and continue exection. An example where we used thread_join was on the menu, where our kernel prevents a race for input entered by the user as it puts the kernel to sleep while the program is running.


Fork System Call

	After Implementing the functions to initialize and manage pids. We moved onto implementing the fork system call. From researching and understanding how sys_fork() is supposed to work we came to the following conclusion. Fork system call essentially takes the current process and copies over its state to the child. The important part for a successful sys_Fork() call is to make sure the child's return value is 0 and the parent receives the PID of its child that just got created.

	First we needed a way to copy the current processes trap frame and pass it on to the child. Since the current trap frame is passed into the system call we used memcpy() function provided to us so we can make a copy of the trapframe to the stack. Now that we have the trapframe copied the next step is to copy the address space. Since we have access to the current thread's address space at all times we used as_copy () to copy over the address space into a new struct.  Alright now that we have the state copied we created a new thread using thread_fork so it could initialize the return values and ensure that the child switches to user mode. The new thread was run in md_forkentry() which took the copied over trap frame and the address space. the first thing the md_forkentry() accomplished was to change the copied over trapframe return value ( 0 for the child) and also increment the pc counter to avoid having another call. Next it takes the trapframe copy of the original process and puts it onto the current thread's stack. Now again since we have access to the current thread's address space we can easily copy over the address space passed in from the parent. Before we move the child to usermode it was important that we flush the TLB since the code will go straight back to user mode without passing through mi_switch. Finally we need to insure that the new child thread is moved over to the user mode by calling mips_usermode().

	Now since we created a new process we need to make sure that we update our global PID structure and let it know that that we have a new process in the kernel. Since this PID structure is a global variable it is important we use proper thread synchronization practises implemented in lab 1 to ensure no race conditions occur. After allocating the PID we can return it to the parent to finalize and make sure the sys_fork() call is successful. A considerable amount of Error checking was required for sys_fork(). The main one was to check that the allocation of memory was successful for each process. If we ran out of memory it was essential that our kernel did not crash but just an error was returned returning the error.

	Problems we ran into included  trying to copy address spaces and trap frames of the current process. initially we started implementing our own functions to perform these tasks but that did not go as planned  but after discussing our issues with TAâ€™s we were guided to using the functions that were already provided. Also, the order of operations in sys_fork was very important it was essential that we copied the state of the process before allocating a new PID because the copy could always fail due to memory constraints. Another important concept we did not really consider initially was the flushing of TLB. At the time we thought that switching to user mode would already go through mi_switch but did not bother checking. After debugging through GDB we eventually realized that we had to flush the TLB ourselves before switching the thread to user mode. 


Getpid System Call

	Getpid is a very basic system call. Once a request has been made the kernel will return the current thread's pid, stored in its thread structure (curthread->pid). Getpid does not return an error because each thread will have an alloted pid, even the kernel process.


Exit System Call

	Exit is the simplified complementing version of waitpid. Since all cases are handled within wait, the exit system call is free to end its thread without worrying about the state of the parent. The exit system call will first disable interrupts ensuring atomicity. The thread will then search through the pidlist list to search for its allotted pid and signal that it has exited. The thread will then wakeup all thread's waiting on its pid. Both these instructions need to be run atomically. Exit needs to be run to completion to ensure two different exit statuses are not read when waitpid is searching to see if its child has exited. This also prevents a thread from sleeping indefinitely. And thread_wakeup(curthread->pid) needs to be run with interrupts off. The current thread will then re-enable interrupts call thread_exit() which cleans up the rest of the thread specific exitting protocol. We designed it this way to ensure that processes have minimal errors when trying to exit. By using atomicity we prevent deadlocks and indefinite waiting. We could have handled these cases within exit but chose to do them within waitpid instead. As long as we handled all cases it would have made no difference where the majority of the code was located. 


Execv System Call

	The biggest challenge we faced was implementing the execv system call. It is very powerful as it allows newly created processes to run programs with  arguments. This system call is a major improvement over the runpgrogram system call previously used, which did not take in any arguments. Some of the tasks we had trouble with included passing arguments from user level to kernel buffer before destroying an address space, passing them back out onto the stack and knowing where to store the pointers and strings respectively, as well as adding correct padding into certain memory locations to avoid a corrupt stack. The following outlines our implementation and why we did things the way we did to overcome all the challenges we faced.

	A call to sys_execv was given a new program to run and arguments to pass into that program. In our implementation we first had to copy these arguments into the kernel buffer before destroying the existing address space. We allocated a new array of strings to store these arguments, and copied them in from the user level to the kernel buffer using the copyinstr function. Once we had the arguments and the program name to open on the kernel buffer, we made a copy of the old address space in case of an error (using as_copy), and then used as_destroy to destroy the current address space. This was done so that we could later create a new address space to load the program into (similar to runprogram). One challenge we faced later on was passing strings onto the stack properly, since the stack requires each pointer to be a multiple of 4 bits. If one of the arguments was, for example, 5 characters long, we needed to ensure the next string didn't start until 8 bits after it. To overcome this problem we added padding onto each string, so for example a 5 character string would have 3 null characters added onto it.

	The key to storing the arguments correctly on the stack wasn't just putting proper padding on the strings, but also putting in proper memory locations for the argument pointers. When pushing arguments onto the stack, we first pushed the pointers, and then the argument strings themselves, and the most difficult part for our team was figuring out exactly what the memory addresses would be. The way we overcame this problem was storing offsets for each argument. We could then set the pointers to have the correct memory location of their respective strings based on the offset from their own location. For example, if we had three arguments, there would be an offset of 16 for the first string, since we allocate 4 bits for each pointer, plus 4 for the NULL argument. Then the address passed in for the first argument pointer would be 16 bits higher (because we decremented the stack pointer) than the location of the actual pointer. The next argument would have an offset as well, which would be 16 plus the size of the first string (including padding). The rest of the arguments were handled in a similar manner. With our implementation of an offset counter, along with correct padding on the strings, we were succesfully able to store arguments on the stack and have the pointers point to correct memory locations. A call to md_usermode could then be made, passing in the stackptr as the userspace address of the arguments (since it held the start of the arguments array), so the program trying to access them knew where to look in memory.

	One final challenge we faced in our implementation of execv was handling corner cases, where execv would fail. Using the man pages, we accounted for most errors, such as running out of memory, I/O errors, and handling invalid pointers. This gave us a bullet-proof implementation of execv that would return errors correctly and never crash the kernel.

	Aside from some key differences in passing over arguments correctly, a lot of the code that handled opening a file, creating a new address space, and declaring an entry point was identical to the old runprogram implementation. The next thing we worked on implementing in our operating system was modifying runprogram to take arguments as well. This would allow our operating system to be much more powerful as we could pass in arguments directly to the programs through the menu. The code for this implementation was similar to execv, however since the arguments were already being passed in on the kernel level, we never had to copy the strings in using copyinstr, or destroy the existing address space to create a new one. The only difference was that we had to pass in arguments correctly, and since we knew our execv was working through rigorous testing, we followed a similar approach where we passed the arguments onto the stack and gave the appropriate location to the arguments in the call to md_usermode.

	As a whole our implementation of copying in arguments into the kernel buffer, adding appropriate padding to the strings, and using offsets to correctly identify memory locations gave us a reliable implementation of execv that neither corrupted the stack nor crashed the kernel. This was a major improvement over the old runprogram call and in turn allowed us to make ruprogram much more powerful by taking in arguments from the menu.


Conclusion

	Implementing these system calls gives us a more powerful operating system that can create new processes, synchronize parent and child processes, and run programs correctly that require arguments from the menu. We faced a lot of challenges as outlined above, however we worked well as a team and by constantly working together and trying out everyone's ideas, we were able to overcome these challenges and implement the correct functionality of all these system calls. 

